package Communication;

import game.Command;
import game.Host;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.net.BindException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.List;

import ui.Menu;

public class Server {
	private static int PORT = 8888;
	boolean started = false;
	private Host host;
	ServerSocket ss = null;
	List<ChatClient> clients = new ArrayList<ChatClient>(); // 保存客户端线程类

	public Server() {
		int whole_userNum = Menu.playNum();
		host = new Host(whole_userNum);
		prepare();
	}

	// 准备
	public void prepare() {
		try {
			ss = new ServerSocket(PORT); // 建立服务端对象
			started = true;
			InetAddress ia = InetAddress.getByName(null);
			Menu.debug("Server@" + ia + " start!");
			// front
			Menu.buildHost(PORT, host.whole_userNum);
		} catch (BindException e) {
			System.out.println("端口使用中...");
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			// someone add
			while (started) {
				Socket s = ss.accept(); // 接收客户端
				// add user
				// 申请一个位置
				ChatClient c = new ChatClient(s, host.new_joinUser());
				new Thread(c).start();
				clients.add(c);
				// front
				// 判断人数是否到齐
				if (host.joined_userNum == host.whole_userNum) {
					try {
						// 显示问题
						Thread.sleep(500);
					} catch (Exception e) {
						e.printStackTrace();
					}
					if (Menu.enableStart()) {
						Menu.cout("starting...");
						start();
					} else {
						Menu.cout("somethingWrong, not start.");
					}
				} else {
					try {
						Thread.sleep(500);
					} catch (Exception e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					Menu.waitJoin();
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				ss.close();
			} catch (IOException e) {
				// TODO 自动生成 catch 块
				e.printStackTrace();
			}
		}
	}

	public void start() {

		// 发送分玩家开始信号
		for (int i = 0; i < clients.size(); i++) {
			ChatClient c = clients.get(i);
			c.send(new SendInfor());
		}
		// 分配排

		// 当游戏未结束时，循环选择玩家
	}

	// 通讯子进程
	class ChatClient implements Runnable { // 建立客户端线程接收，发送数据
		private Socket s;
		ObjectInputStream dis = null;
		ObjectOutputStream dos = null;
		boolean bConnected = false;
		SendInfor umd;

		// 开启分线程
		public ChatClient(Socket s, int uid) {
			this.umd = new SendInfor();
			this.umd.uid = uid;
			this.s = s;
			try {
				dis = new ObjectInputStream(s.getInputStream());
				dos = new ObjectOutputStream(s.getOutputStream());
				bConnected = true;

				// 发送初始化信息
				send(new SendInfor(Command.INIT, null, uid));
				// Menu.debug("send success.");
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		void send(SendInfor umd) {
			try {
				dos.writeObject(umd);
			} catch (SocketException e) {
				System.out.println(umd.name + "退出了...");
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		public void handle(SendInfor umd) {
			switch (umd.command) {
			case INIT:
				Menu.cout("joinerName is: " + umd.name);
				break;
			default:
				break;
			}
		}

		// TODO
		public void run() {
			try {
				while (bConnected) {
					// receive information
					SendInfor umd = (SendInfor) dis.readObject();

					// handle information
					handle(umd);

				}
			} catch (EOFException e) {
				System.out.println(umd.name + "退出了");
			} catch (IOException e) {
				e.printStackTrace();
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			} finally {
				if (dis != null)
					if (s != null)
						try {
							dis.close();
							s.close();
							dos.close();
						} catch (IOException e) {
							e.printStackTrace();
						}
			}
		}
	}

	// Server exit means kill the game;
	public void stop() throws IOException {
		for (int i = 0; i < clients.size(); i++) {

			ChatClient c = clients.get(i);
			c.dis.close();
			c.s.close();
			c.dos.close();
		}

		Menu.cout("Server exit.");
	}
}
